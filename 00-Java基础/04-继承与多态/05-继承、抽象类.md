# 一. 继承

- [ ] 面向对象三大特征：封装、**继承**、多态
- [ ] 继承是多态的前提：没有继承，就没有多态
- [ ] 继承主要解决的问题：**共性抽取**
- [ ] 继承的体现：`extends`、`implements`
- [ ] 子类拥有父类的内容，也拥有自己专有的内容；子类也可以当作一个父类
- [ ] 代码中的格式：
- 父类的定义：一个普通的类定义
- 子类的定义：`public class 子类名称 extends 父类名称{}`

## 1. 对成员变量的影响

- [ ] 父类和子类的成员变量重名时，有两种访问方式：

- 直接通过子类对象访问成员变量
  - 等号左边是谁，就优先用谁，没有则向上找
- 间接通过成员方法访问成员变量
  - 方法属于谁，就优先用谁

- [ ] 区分局部变量、父类成员变量、本类成员变量重名的方法：`this`、`super`关键字

- 局部变量：`直接写变量名`
- 本类的成员变量：`this.成员变量名`
- 父类的成员变量名：`super.成员变量名`

## 2. 对成员方法的影响

- [ ] 成员方法重名：

- 在继承关系中，方法的名称一样，参数列表也一样-----------重写（Override）、也叫覆盖
- 创建的是子类对象，则优先使用子类的方法

- [ ] 方法覆盖注意事项：

- IDEA中写上`@Override`注解可以来检测是否是方法覆盖--------安全检测手段（推荐）
- 子类方法的返回值必须小于等于父类方法的返回值范围
- 子类方法的权限必须大于等于父类方法的权限修饰符。

> `public` > `protected` > `(default)` > `private` 	注：`defualt`不是关键字，表示留空

## 3. 对构造方法的影响

- [ ] 继承关系时，父子类构造方法的访问特点：

- 子类必须调用父类构造方法，不写则赠送`super()`（子类构造方法中默认隐含的`super()`调用）----> 先执行父类构造方法
- 只有子类构造方法，才能调用父类构造方法
- 子类构造可以通过`super`关键字调用父类重载构造方法
- `super`的父类构造调用，必须是子类构造方法的第一个语句，也是唯一一个

## 4. super关键字典型应用

- [ ] 在子类的成员方法中，访问父类的成员变量
- [ ] 在子类的成员方法中，访问父类的成员方法
- [ ] 在子类的构造方法中，访问父类的构造方法

## 5. this关键字的典型应用

- [ ] 在本类的成员方法中，访问本类的成员变量
- [ ] 在本类的成员方法中，访问本类的另一个成员方法
- [ ] 在本类的构造方法中，访问本类的另一个构造方法
  - `this(…)`调用也必须是构造方法的第一个语句，也是唯一一个
  - `super`和`this`两种构造调用，不能同时使用

## 6. super/this内存示意图

![](F:\MDSource\MD\黑马-Java-57期-讲义-笔记-资料\01-Java基础\04.继承与多态\09.【继承、super、this、抽象类】\03_参考\03-super与this的内存图.png)

## 7. 继承的特性

- Java中的继承是**单继承**的：一个类的直接父类只能用唯一一个

- Java中可以**多级继承**
- 一个父类可以有很多子类

# 二. 抽象类

- [ ] 抽象方法：父类中不确定具体如何实现的方法-------> 抽象方法

- [ ] 抽象类：包含抽象方法的类-----抽象方法所在的类，必须是抽象类
- [ ] 格式：

- 加上`abstract`关键字，去掉大括号，没有方法体
  - `public abstract void eat();`

- [ ] 如何使用抽象方法、抽象类：

- 不能直接创建`new`抽象类对象
- 必须用一个子类来继承抽象父类
- 子类必须**覆盖重写（实现）**抽象类中的**所有**抽象方法----去掉`abstract`关键字----IDEA中快捷键`alt+Insert`
- 创建子类对象进行使用

# 三. 接口

- [ ] 接口就是多个类的**公共的规范标准**

- [ ] 接口是一种引用类型，最重要的内容就是其中的抽象方法
- [ ] 定义接口的格式：

````java
public interface 接口名称{
    //接口内容
}
````

- 如果是Java 7，接口内容中可以包含：常量、抽象方法
- 如果是Java 8+，还可以额外包含：默认方法、静态方法
- 如果是Java 9+，还可以额外包含：私有方法

```java
- 接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract
- 这两个关键字，可以选择性省略（初学不推荐）
```

- [ ] 接口使用步骤：

- 不能直接使用，必须有一个实现类来实现接口
  - `public class 实现类名称 implements 接口名{}`
- 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法
- 创建**实现类**的对象，进行使用

## 接口包含--默认方法

- [ ] 问题描述：

接口升级问题：接口中新增了一个抽象方法，那么在实现类中就必须要修改去实现新增的抽象方法

- [ ] 解决方案：

新添加的方法--->定义成默认方法--->实现类中不用覆盖重写

```java
public default 返回值类型 方法名称（参数列表）{
    
}
```

- 接口的默认方法，可以通过接口实现类对象，直接调用
- 接口的默认方法，也可以被接口实现类进行覆盖重写

## 接口包含--静态方法

```java
public static 返回值类型 方法名称（参数列表）{
    
}
```

- 不能通过接口实现类的对象来调用接口中的静态方法
- 正确方法：通过接口名称直接调用接口中的静态方法

## 接口包含--私有方法

- [ ] 问题描述：

抽取一个共有方法，解决两个默认方法之间重复代码的问题，但是这个公共方法不应该让实现类使用，应该是私有化的

- [ ] 解决方案：

- 普通私有化方法：解决多个默认方法之间**重复代码**问题
  - `private 返回值类型 方法名称（参数列表）{}`
- 静态私有方法：解决多个静态方法之间**重复代码**问题
  - `private static 返回值类型 方法名称（参数列表）{}`
- 只有接口自己能调用

## 接口包含--成员变量

接口中也可以定义“成员变量”，但必须使用`public static final`三个关键字进行修饰,从效果上看，其实就是接口的【常量】

- [ ] 格式与注意事项：

- `public static final 数据类型 常量名称 = 数据值;`
- `public static final`关键字可以省略不写
- 接口中的常量，必须进行赋值
- 推荐：常量名称完全大写，并用下划线进行分隔-----`NUM_MONEY`

## 注意事项

- 接口不能有静态代码块
- 接口不能用构造方法
- 一个类的有且只有一个直接父类，但是一个类可以同时实现多个接口----用逗号隔开
  - `public class Interfaceimpl implements MyInterface1,MyInterface2{}`

- 如果实现类所实现的多个接口类中有重名的抽象方法，则只需要重写覆盖一遍
- 如果实现类所实现的多个接口类中有重名的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写
- 一个类的直接父类中的方法和接口当中的默认方法产生了冲突，**优先使用父类**当中的方法

## 类与接口的关系

- 类与类之间是单继承的，直接父类只有一个
- 类与接口之间是多实现的，一个类可以实现多个接口、
- 接口与接口之间是多继承的

# 四. 多态

- [ ] `extends`继承或者`implements`实现，是多态性的前提

- [ ] **对象**的多态性：一个对象拥有多种形态
- [ ] 代码中体现多态性：

- 父类引用指向子类对象
  - `父类名称 对象名 = new 子类名称();`  		左父右子---子类被当作父类来看待（一只猫被当作动物看待）
  - `接口名称 对象名 = new 实现类名称();`

## 成员变量的访问规则

- 直接通过对象名称访问：看**等号左边**是谁，就优先用谁，没有则向上（父类）找
- 间接通过成员方法访问：看**该方法属于**谁，就优先用谁，没有则向上（父类）找
- 口诀：编译看左边，运行还看左边

## 成员方法的访问规则

- 看`new`的是谁，就优先用谁，没有则向上（父类）找
- 口诀：编译看左边，运行看右边

```java
ublic class Demo03MultiMethod {
    public static void main(String[] args) {
        Fu obj = new Zi();
        obj.method();//父子都有，优先用子
        obj.methodFu();//子类没有，父类有,向上找父类
        //编译看左边，左边是Fu，Fu中没有methodZi()方法，所以编译报错
        //obj.methodZi();错误写法
    }
}
```

## 多态的好处

![](F:\MDSource\MD\黑马-Java-57期-讲义-笔记-资料\01-Java基础\04.继承与多态\10.【接口、多态】\03_参考\04-使用多态的好处.png)

# 五. 引用类型转型

多态的转型分为向上转型和向下转型

## 对象的向上转型

- [ ] 对象的向上转型，其实就是多态写法

- `父类名称 对象名 = new 子类名称();`  		子类被当作父类来看待（一只猫被当作动物看待）

- **向上转型一定是安全的：从小范围转向了大范围**

## 对象的向下转型

- [ ] 问题描述：

- 向上转型的弊端---对象一旦向上转型为父类，就无法调用子类原本持有的内容

- [ ] 对象的向下转型

- 其实就是一个【还原】的动作

- [ ] 格式：

- `子类名称 对象名 = （子类名称）父类对象;`

```java
Animal animal = new Cat();//本来是猫，向上转型为动物
Cat cat = (Cat) animal;//将本来已经转型为动物的猫，还原成本来的猫
```

- [ ] 注意事项：

- 对象创建的时候必须保证本来就是猫
- 类似于基本数据类型的强制转换

# 六. instanceof关键字

- [ ] 问题描述：

- 如何知道一个父类引用的对象，本来是什么子类？（对象本来创建的时候是一只猫呢？）

- [ ] 格式：

- `对象名 instanceof 类名称`
- 返回一个`boolean`结果，判断了前面的对象能不能当作后面类型的实例

# 七. 多态-接口的练习

![](F:\MDSource\MD\黑马-Java-57期-讲义-笔记-资料\01-Java基础\04.继承与多态\10.【接口、多态】\03_参考\06-笔记本电脑案例分析.png)

## Usb接口

```java
package cn.arnold.day03.demo04;

public interface Usb {
    //开启usb
    public void openUsb();

    //关闭usb
    public void closeUsb();
}
```

## 鼠标实现类

```java
package cn.arnold.day03.demo04;

public class Mouse implements Usb {
    @Override
    public void openUsb() {
        System.out.println("打开鼠标usb");
    }

    @Override
    public void closeUsb() {
        System.out.println("关闭鼠标usb");
    }

    //鼠标点击功能
    public void click() {
        System.out.println("鼠标点击");
    }
}

```

## 键盘实现类

```java
package cn.arnold.day03.demo04;

public class KeyBoard implements Usb {
    @Override
    public void openUsb() {
        System.out.println("打开键盘usb");
    }

    @Override
    public void closeUsb() {
        System.out.println("关闭键盘usb");
    }

    //键盘输入功能
    public void type() {
        System.out.println("键盘输入");
    }
}

```

## 电脑类

```java
package cn.arnold.day03.demo04;

public class KeyBoard implements Usb {
    @Override
    public void openUsb() {
        System.out.println("打开键盘usb");
    }

    @Override
    public void closeUsb() {
        System.out.println("关闭键盘usb");
    }

    //键盘输入功能
    public void type() {
        System.out.println("键盘输入");
    }
}

```

## 主方法类

```java
package cn.arnold.day03.demo04;

/*
描述笔记本类，实现笔记本使用鼠标、键盘
1.usb接口：包含开启、关闭功能
2.笔记本类：包含开机、关机、使用usb设备功能
3.鼠标实现类：实现usb接口、鼠标点击功能
4.键盘实现类：实现usb接口、键盘输入功能
 */
public class Main {
    public static void main(String[] args) {
        Computer com = new Computer();
        //开机
        com.powerOn();
        //使用鼠标usb设备
        Usb usb = new Mouse();//将鼠标向上转型为Usb
        com.useUsbDevice(usb);
        //使用键盘设备
        com.useUsbDevice(new KeyBoard());//使用匿名对象，隐藏了keyboard向上转型为Usb操作
        /*KeyBoard keyboard = new KeyBoard();
        com.useUsbDevice(keyboard);*/
        //关机
        com.powerOff();
    }
}

```

# 八. final关键字

- [ ] 含义：

- 最终的、不可改变的

## 修饰一个类

- 格式：`修饰符 final class 类名称{}`

- 含义：
  - 当前这个类不能有任何子类（太监类）
  - 其中所有的成员方法都无法进行覆盖重写（因为没儿子）

## 修饰一个方法

- 格式：`修饰符 final 返回值类型 方法名（参数列表）{}`
- 含义：不能被覆盖重写

注意事项：

- 对于类和方法来说，不能同时使用`abstract`和`final`关键字-----互相矛盾

## 修饰一个局部变量

- 格式：`修饰符 final 变量类型 变量名 = 值`  				必须赋值
- 含义：一次赋值，终生不变

注意事项：

- 对于基本数据类型，不可变的是数值---------只能赋值一次
- 对于引用数据类型，不可变的是地址值 ----- 只能`new`一次

## 修饰成员变量

- 格式：`private final 变量类型 变量名`
- 含义：变量也是不可变的-----`Setter`方法失效

注意事项：

- 由于成员变量有默认值，当使用`final`关键字后，编译器将不再赠送默认值，必须手动赋值
- 要么直接赋值，要么通过构造方法赋值（二者选其一）
- 通过构造方法赋值必须保证所有重载形式的构造方法都对这个变量赋值

# 九. 权限修饰符

|                 | public | protected | （default）省略不写 | private |
| --------------- | ------ | --------- | ------------------- | ------- |
| 同一类中        | YES    | YES       | YES                 | YES     |
| 同一个包        | YES    | YES       | YES                 | NO      |
| 不同包---子类   | YES    | YES       | NO                  | NO      |
| 不同包---非子类 | YES    | NO        | NO                  | NO      |

# 十. 内部类

例如：身体和心脏（内部类）的关系，心脏必须依赖于身体才有用

## 成员内部类

- [ ] 格式：

```java
修饰符 class 外部类名称 {
    修饰符 class 内部类名称 {
        //...
    }
    //...
}
```

- [ ] 使用规则：

- 内用外，随意访问；外用内，需要内部对象

- [ ] 编译后的`.class`文件信息：`Body.class`、`Body$Heart.class`

- [ ] 如何使用成员内部类：

- 间接访问：在外部类的方法中，使用内部类，在main中只是调用外部类的方法
- 直接访问：`外部类名称.内部类名称 对象名称 = new 外部类名称().内部类名称();`，在main中通过创建的对象

- [ ] 内部类、外部类成员变量重名：

- `外部类名称.this.外部类成员变量名`

## 局部内部类（包含匿名内部类）

- [ ] 一个类定义在一个方法内部------局部内部类

- [ ] 含义：只有当前所属的方法才能使用它，出了这个方法就不能用了

- [ ] 格式：

```java
public 返回值 方法名(参数列表) {
    class 内部类名称 {
        //...
    }
    //...
}
```

- [ ] 注意事项：

- 局部内部类，如果希望访问方法的局部变量，那么这个局部变量必须是【有效`final`的】
- 原因：局部类对象（堆）的生命周期比局部变量（栈）长

## 内部类的修饰符规则

- 外部类：`publi`/`(default)`
- 成员内部类：`public`/`protected`/`(default)`/`private`
- 局部内部类：`(default)`

## 匿名内部类（重点）

- [ ] 问题描述：

- 如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，这种情况下就可以省略掉该类的定义，改为使用**匿名内部类**

- [ ] 定义格式：直接`new`接口

```java
接口名称 对象名 = new 接口名称(){
    //覆盖重写接口方法----匿名内部类
};
```

- [ ] 注意事项：`接口名称 对象名 = new 接口名称(){...};`

- new代表创建的动作
- 接口名称就是匿名内部类需要实现的那个接口
- `{...}`才是匿名内部类的内容
- 匿名内部类，在创建对象的时候，只能使用唯一的一次------需要重复使用接口方法则不要用匿名内部类
- 匿名对象，在调用方法的时候，只能调用唯一的一次(一次只能调用一个方法)---`new Student().studyCoding()`

# 十一. 引用类型用法总结

基本类型可以作为成员变量、作为方法的参数、作为方法的返回值，引用类型同样可以-----`String`就是引用类型

## class作为成员变量



## interface作为成员变量



## interface作为方法的参数和返回值

